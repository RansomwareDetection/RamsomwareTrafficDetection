import torch
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay, roc_auc_score, balanced_accuracy_score
from sklearn.utils.class_weight import compute_class_weight
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import joblib
import time

class MalwareDetectionModel(nn.Module):
    def __init__(self):
        super(MalwareDetectionModel, self).__init__()

        # 1D CNN layers
        self.conv1 = nn.Conv1d(in_channels=1, out_channels=64, kernel_size=3)
        self.conv2 = nn.Conv1d(in_channels=64, out_channels=128, kernel_size=3)
        self.batch_norm1 = nn.BatchNorm1d(128)  # Batch normalization after Conv2

        # Bidirectional GRU
        self.gru = nn.GRU(input_size=128, hidden_size=64, num_layers=1, batch_first=True, bidirectional=True)

        # Fully connected layers
        self.fc1 = nn.Linear(128, 64)  # Bidirectional GRU doubles the hidden size
        self.fc2 = nn.Linear(64, 1)  # Binary classification

        # Dropout
        self.dropout = nn.Dropout(0.7)

    def forward(self, x):
        x = x.unsqueeze(1)  # Add channel dimension for Conv1D: (batch_size, 1, seq_len)
        x = nn.ReLU()(self.conv1(x))
        x = nn.ReLU()(self.conv2(x))
        x = self.batch_norm1(x)

        # GRU
        x, _ = self.gru(x.permute(0, 2, 1))  # Permute for GRU: (batch_size, seq_len, input_size)
        x = x[:, -1, :]  # Take output from the last time step

        # Fully connected layers
        x = nn.ReLU()(self.fc1(x))
        x = self.fc2(x)
        return x

from sklearn.utils.class_weight import compute_class_weight
import torch

def train_malware_detection_model():
    try:
        print("Starting training process...")

        # Load and preprocess dataset
        data = pd.read_csv("C:/KMIT/PS/Ransomware Detection/Datasets/Android_Ransomeware.csv")
        data = data[data['Label'].isin(['Benign', 'RansomBO'])]  # Filter classes
        data['Label'] = data['Label'].apply(lambda x: 0 if x == 'Benign' else 1)  # Encode labels

        selected_columns = [' ACK Flag Count', ' Fwd Header Length.1', ' Avg Bwd Segment Size', ' Avg Fwd Segment Size',
                            ' Average Packet Size', ' Down/Up Ratio', ' ECE Flag Count', ' CWE Flag Count', ' URG Flag Count',
                            ' PSH Flag Count', 'Fwd Packets/s', ' RST Flag Count', ' SYN Flag Count', 'FIN Flag Count',
                            ' Max Packet Length', ' Min Packet Length']

        X = data[selected_columns]
        y = data['Label']

        # Handle missing values
        X = X.apply(pd.to_numeric, errors='coerce')
        X.fillna(X.mean(), inplace=True)

        # Standardize features
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        # Debugging - check X_scaled and y
        print(f"Shape of X_scaled: {X_scaled.shape}")
        print(f"Shape of y: {y.shape}")

        # Check class distribution
        print("Class distribution:\n", y.value_counts())

        # Class weights
        class_weights = compute_class_weight(class_weight='balanced', classes=np.unique(y), y=y)
        class_weights = torch.tensor(class_weights, dtype=torch.float32)

        # Train-test split
        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.3, random_state=42)
        print(f"Training samples: {len(X_train)}, Test samples: {len(X_test)}")

        # Convert data to PyTorch tensors
        X_train_tensor = torch.tensor(X_train, dtype=torch.float32)
        y_train_tensor = torch.tensor(y_train.values, dtype=torch.float32).view(-1, 1)
        X_test_tensor = torch.tensor(X_test, dtype=torch.float32)
        y_test_tensor = torch.tensor(y_test.values, dtype=torch.float32).view(-1, 1)

        # Create DataLoader for batching
        train_dataset = TensorDataset(X_train_tensor, y_train_tensor)
        train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)

        # Initialize model, loss function, and optimizer
        model = MalwareDetectionModel()

        # Use BCEWithLogitsLoss with class weights
        criterion = nn.BCEWithLogitsLoss(pos_weight=class_weights[1])  # `pos_weight` is the weight for the positive class
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
        scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.1)

        # Training Loop
        print("Training started...")
        for epoch in range(10):
            model.train()
            epoch_loss = 0.0

            for inputs, targets in train_loader:
                optimizer.zero_grad()
                outputs = model(inputs)
                loss = criterion(outputs, targets)
                loss.backward()
                optimizer.step()
                epoch_loss += loss.item()

            scheduler.step()
            print(f"Epoch [{epoch + 1}/10], Loss: {epoch_loss / len(train_loader):.4f}")

        # Save the trained model and scaler
        torch.save(model.state_dict(), "improved_model.pth")
        joblib.dump(scaler, "improved_scaler.pkl")
        print("Model and scaler saved successfully.")

        # Evaluation
        print("Evaluating the model...")
        model.eval()
        with torch.no_grad():
            val_outputs = model(X_test_tensor)
            y_pred = torch.sigmoid(val_outputs).round()

            # Validation Metrics
            print("\nClassification Report:")
            print(classification_report(y_test_tensor, y_pred))
            balanced_acc = balanced_accuracy_score(y_test_tensor, y_pred)
            print(f"Balanced Accuracy: {balanced_acc:.4f}")
            roc_auc = roc_auc_score(y_test_tensor, torch.sigmoid(val_outputs).numpy())
            print(f"ROC-AUC Score: {roc_auc:.4f}")

            # Confusion Matrix
            cm = confusion_matrix(y_test_tensor, y_pred)
            disp = ConfusionMatrixDisplay(confusion_matrix=cm)
            disp.plot(cmap=plt.cm.Blues)
            plt.show()

    except Exception as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    train_malware_detection_model()


